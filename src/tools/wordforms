#!/bin/sh

# check for incorrect number of arguments
case $# in
	0|1|2) echo "Usage: wordforms [-s | -p] dictionary.aff dictionary.dic word
-s: print only suffixed forms
-p: print only prefixed forms";
	exit 1;;
esac
# this switches whether to print only suffixed, prefixed or all forms of stem
fx=0
case $1 in
	-s) fx=1; shift;;
	-p) fx=2; shift;;
esac
# clear any previous temporary dictionary
test -h /tmp/wordforms.aff && rm /tmp/wordforms.aff
# make a symbolic link of the aff file
ln -s "$PWD/$1" /tmp/wordforms.aff

# find all lines exactly matching the search
# stem, plus optional forward slash and flags
entries=""
count=0
for entry in $( grep -E "^$3(/|$)" $2 ) ; do
	[ ! -z $entries ] && entries="$entries|$entry"
	[ -z $entries ] && entries="$entry"
	count=$((count+1))
done
# if no stem was found then exit
[ $count -eq 0 ] && return 1
# number of stems found is the number of entries
# in the temporary dictionary
echo "$count" > /tmp/wordforms.dic
# add entries to temporary dictionary
echo "$entries" | sed 's/|/\n/g' >> /tmp/wordforms.dic

# collect the dictionary settings we need to optimise the word generation
grep -q '^COMPLEXPREFIXES' $1 && complex_prefixes="yes" || complex_prefixes=""
flag_type="unicode"
case "$( awk '/^FLAG/ && NF>1 { print $2 }' $1 )" in
	num) flag_type="num";;
	long) flag_type="long";;
esac


# generate the different potential words
awk -v fx="$fx" -v complex_prefixes="$complex_prefixes" -v flag_type="$flag_type" '
function get_regex_from_flags(input_flags) {
	delete flag_array
	delete long_flags
	output_regex=""
	temp=""
	
	if (input_flags) {
		split(input_flags, flag_particles, (flag_type=="num" ? "," : "" ))
		if (flag_type=="long") {
			for (i in flag_particles) {
				temp=temp flag_particles[i]
				if (length(temp)==2) {
					#flag_particles[i] && flag_particles[i-1] &&) {
					long_flags[temp]=temp
					temp=""
				}
			}
			for (i in long_flags) {
				flag_array[length(flag_array)+1]=long_flags[i]
			}
		}
		else {
			for (i in flag_particles) {
				flag_array[length(flag_array)+1]=flag_particles[i]
			}
		}
		output_regex=output_regex (flag_type!="unicode" ? "(" : "[")
		for (flag in flag_array) {
			if (flag_array[flag]) {
				output_regex=output_regex flag_array[flag] (flag_type!="unicode" ? "|" : "")
			}
		}
		if (flag_type!="unicode") output_regex=substr(output_regex, 1, (length(output_regex) - 1));
		output_regex=output_regex (flag_type!="unicode" ? ")" : "]")
		return output_regex
	}
	else {
		return 0
	}
}

# this runs on the .dic file to get stem and flag data
NR==FNR && NR>1 && /\// && NF==1 {
	split($1,dic_line,"/")
	stem=dic_line[1]
	if (dic_line[2]) stem_flags=stem_flags dic_line[2];
}

# this runs on the .dic file to get any stems without flags
NR==FNR && NR>1 && NF==1 && !/\// { stem=$1 }

# this runs on the first line of the .aff file
# to prepare regex to search the file with
NR!=FNR && FNR==1 {
	# generate regex matching all flags used by the stem
	flag_regex=get_regex_from_flags(stem_flags)
	# if no flags have been used then
	# only the dictionary form is correct
	if (!flag_regex) exit 0;
}

# this runs on the .aff file to get affix data
NR!=FNR && /^[SP]FX/ && NF>4 && $4 !~ "[1-9][0-9]*" {
	split($4,a,"/")
	clen=($3=="0") ? 0 : length($3)
	# put every suffix in $affix
	if (($1=="SFX" && fx!=2) || ($1=="PFX" && fx!=1)) affix_db[$0]=$0; #could strip out the unused parts of $0?
	next
}

# this runs after processing the .aff file
END {
	# if there are no variations to generate
	if (!flag_regex) { print stem; exit 0 }
	
	stem_length=length(stem)
	all_variations[stem]=stem
	
	# gather only the affixes referenced by
	# the dictionary entries through their stems
	# and put them together in $regexed_affixes
	for (line in affix_db) {
		split(line, line_particles)
		split(line_particles[4], add_and_flags, "/")
		if (line_particles[2] ~ "^"flag_regex"$") { #could add beginning / end of stem ~ line_particles[5] here
			if (( line_particles[1]=="PFX" && stem ~ "^"line_particles[5]".*" ) || ( line_particles[1]=="SFX" && stem ~ ".*"line_particles[5]"$" )) {
				regexed_affixes[line]=line
				continue
			}
		}
	}
	
	# find the affixes referenced by the
	# top-level affixes and add them to
	# a separate array $sub_affix_regex
	for (line in regexed_affixes) {
		sub_affix_regex=""
		add_and_flags[1]=""
		add_and_flags[2]=""
		split(line, line_particles)
		split(line_particles[4], add_and_flags, "/")
		if (add_and_flags[2]) {
			sub_affix_regex=get_regex_from_flags(add_and_flags[2])
			for (sub_line in affix_db) {
				split(sub_line, sub_line_particles)
				split(sub_line_particles[4], sub_add_and_flags, "/")
				if (sub_line_particles[2] ~ "^"sub_affix_regex"$") {
					sub_regexed_affixes[sub_line]=sub_line
				}
			}
		}
	}
	
	# generate the stem with up to three
	# suffixes and / or prefixes, two prefixes
	# if dic rule COMPLEXPREFIXES exists, or
	# (by default) two suffixes, and one affix
	# of the opposite type i.e. f-stem-suff-suff
	for (affix in regexed_affixes) {
		split(affix, affix_particles)
		split(affix_particles[4], add_and_flags, "/")
		cut_chars=(affix_particles[3]=="0" ? 0 : length(affix_particles[3]))
		if (affix_particles[1]=="PFX") {
			if (stem_length<=cut_chars || flag_type==1) continue;
			pref_stem=(add_and_flags[1]=="0" ? "" : add_and_flags[1]) substr(stem, cut_chars+1)
			pref_stem_length=length(pref_stem)
			all_variations[pref_stem]=pref_stem
			for (sub_affix in sub_regexed_affixes) {
				split(sub_affix, sub_affix_particles)
				split(sub_affix_particles[4], sub_add_and_flags, "/")
				sub_cut_chars=(sub_affix_particles[3]=="0" ? 0 : length(sub_affix_particles[3]))
				if (complex_prefixes && sub_affix_particles[1]=="PFX" && pref_stem_length>sub_cut_chars && pref_stem ~ "^"sub_affix_particles[5]".*") {
					pref_pref_stem=(sub_add_and_flags[1]=="0" ? "" : sub_add_and_flags[1]) substr(pref_stem, sub_cut_chars+1)
					pref_pref_stem_length=length(pref_pref_stem)
					all_variations[pref_pref_stem]=pref_pref_stem
					for (sub_sub_affix in regexed_affixes) {
						split(sub_sub_affix, sub_sub_affix_particles)
						split(sub_sub_affix_particles[4], sub_sub_add_and_flags, "/")
						sub_sub_cut_chars=(sub_sub_affix_particles[3]=="0" ? 0 : length(sub_sub_affix_particles[3]))
						if (sub_sub_affix_particles[1]!="SFX" || pref_pref_stem_length>sub_sub_cut_chars || pref_pref_stem !~ ".*"sub_affix_particles[5]"$") continue;
						pref_pref_stem_suff=substr(pref_pref_stem, 1, pref_pref_stem_length-sub_sub_cut_chars) (sub_sub_add_and_flags[1]=="0" ? "": sub_sub_add_and_flags[1])
						all_variations[pref_pref_stem_suff]=pref_pref_stem_suff
					}
				}
				if (sub_affix_particles[1]=="SFX" && pref_stem_length>sub_cut_chars && pref_stem ~ ".*"sub_affix_particles[5]"$") {
					pref_stem_suff=substr(pref_stem, 1, pref_stem_length-sub_cut_chars) (sub_add_and_flags[1]=="0" ? "": sub_add_and_flags[1])
					all_variations[pref_stem_suff]=pref_stem_suff
				}
			}
		}
		else if (affix_particles[1]=="SFX") {
			if (stem_length<=cut_chars || flag_type==2) continue;
			stem_suff=substr(stem, 1, stem_length-cut_chars) (add_and_flags[1]=="0" ? "": add_and_flags[1])
			stem_suff_length=length(stem_suff)
			all_variations[stem_suff]=stem_suff
			for (sub_affix in sub_regexed_affixes) {
				split(sub_affix, sub_affix_particles)
				split(sub_affix_particles[4], sub_add_and_flags, "/")
				sub_cut_chars=(sub_affix_particles[3]=="0" ? 0 : length(sub_affix_particles[3]))
				if (sub_affix_particles[1]=="PFX" && stem_suff_length>sub_cut_chars && stem_suff ~ "^"sub_sub_affix_particles[5]".*") {
					pref_stem_suff=(sub_add_and_flags[1]=="0" ? "" : sub_add_and_flags[1]) substr(stem_suff, sub_cut_chars+1)
					all_variations[pref_stem_suff]=pref_stem_suff
				}
				if (!complex_prefixes && sub_affix_particles[1]=="SFX" && stem_suff_length>sub_cut_chars && stem_suff ~ ".*"sub_affix_particles[5]"$") {
					stem_suff_suff=substr(stem_suff, 1, stem_suff_length-sub_cut_chars) (sub_add_and_flags[1]=="0" ? "": sub_add_and_flags[1])
					all_variations[stem_suff_suff]=stem_suff_suff
					for (sub_sub_affix in regexed_affixes) {
						split(sub_sub_affix, sub_sub_affix_particles)
						if (sub_sub_affix_particles[1]!="PFX" || stem_suff_suff_length>sub_sub_cut_chars || stem_suff_suff !~ "^"sub_sub_affix_particles[5]".*") continue;
						split(sub_sub_affix_particles[4], sub_sub_add_and_flags, "/")
						sub_sub_cut_chars=(sub_sub_affix_particles[3]=="0" ? 0 : length(sub_sub_affix_particles[3]))
						pref_stem_suff_suff=(sub_sub_add_and_flags[1]=="0" ? "" : sub_sub_add_and_flags[1]) substr(stem_suff_suff, sub_sub_cut_chars+1)
						all_variations[pref_stem_suff_suff]=pref_stem_suff_suff
					}
				}
			}
		}
	}
	
	for (variation in all_variations) {
		# finally, print all the unique prefix / stem / suffix variations
		print variation
	}
}
' /tmp/wordforms.dic /tmp/wordforms.aff | hunspell -d /tmp/wordforms -G -l | sort -u
