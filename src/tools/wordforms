#!/bin/sh

# check for incorrect number of arguments
case $# in
	0|1|2) echo "Usage: wordforms [-s | -p] dictionary.aff dictionary.dic word
-s: print only suffixed forms
-p: print only prefixed forms";
	exit 1;;
esac
# this switches whether to print only suffixed, prefixed or all forms of stem
fx=0
case $1 in
	-s) fx=1; shift;;
	-p) fx=2; shift;;
esac
# clear any previous temporary dictionary
test -h /tmp/wordforms.aff && rm /tmp/wordforms.aff
# make a symbolic link of the aff file
ln -s "$PWD/$1" /tmp/wordforms.aff

# find all lines exactly matching the search
# stem, plus optional forward slash and flags
entries=""
count=0
for entry in $( grep -E "^$3(/|$)" $2 ) ; do
	[ ! -z $entries ] && entries="$entries|$entry"
	[ -z $entries ] && entries="$entry"
	count=$((count+1))
done
# if no stem was found then exit
[ $count -eq 0 ] && return 1
# number of stems found is the number of entries
# in the temporary dictionary
echo "$count" > /tmp/wordforms.dic
# add entries to temporary dictionary
echo "$entries" | sed 's/|/\n/g' >> /tmp/wordforms.dic

# collect the dictionary settings we need to optimise the word generation
grep -q '^COMPLEXPREFIXES' $1 && complex_prefixes="yes" || complex_prefixes=""
flag_type="unicode"
case "$( awk '/^FLAG/ && NF>1 { print $2 }' $1 )" in
	num) flag_type="num";;
	long) flag_type="long";;
esac


# generate the different potential words
awk -v fx="$fx" -v complex_prefixes="$complex_prefixes" -v flag_type="$flag_type" '
BEGIN {
	delete regexed_prefixes
	delete regexed_suffixes
	
	delete all_variations
	delete to_be_processed
	all_suffixes_regex="("
	all_prefixes_regex="("
}

function debug(text) {
	print text >"/dev/tty"
}

function affix_word(word, input_flags, location) {
	#debug("\nCALL START\n" word " + " input_flags " + " location)
	return_value=0
	#separate the flags
	#for each flag
	local_flag_regex=get_regex_from_flags(input_flags)
	#print "input flags: " input_flags >"/dev/tty"
	#for 
	split(local_flag_regex, individual_flags, "|")
	for (local_flag in individual_flags) {
		#debug("checking flag: " individual_flags[local_flag])
		if (individual_flags[local_flag] ~ "^"all_suffixes_regex"$" && fx!=2) {
			#debug("- " individual_flags[local_flag] " is SFX")
			if (location ~ "^(3|23|123)$") {
				#debug("-- (3|23|123) suffixing the stem")
				for (touching_suffix in regexed_suffixes) {
					split(regexed_suffixes[touching_suffix], affix_particles)
					#debug("--- " individual_flags[local_flag] " , " affix_particles[2])
					if (affix_particles[2]!=individual_flags[local_flag]) continue;
					split(affix_particles[4], add_and_flags, "/")
					cut_chars=(affix_particles[3]=="0" ? 0 : length(affix_particles[3]))
					affixed_word=substr(word, 1, length(word)-cut_chars) (add_and_flags[1]=="0" ? "": add_and_flags[1])
					#debug("--- created suffixed word: " affixed_word)
					if (!fx && location !~ 1) {
						# strip out the other suffixes at the same level as the one we re processing
						substring_flags=""
						#debug(all_suffixes_regex)
						split(input_flags, substring_flag_particles, all_suffixes_regex)
						for(i in substring_flag_particles) {
							substring_flags=substring_flags substring_flag_particles[i]
						}
						#debug("prefixes flags: " substring_flags)
						return_value=1
						to_be_processed[affixed_word "/" substring_flags "/" location]=affixed_word "/" substring_flags
						#debug("-- to be processed (same level): " affixed_word "/" substring_flags "/" location)
					}
					if (add_and_flags[2] && !complex_prefixes && location !~ 5) {
						return_value=1
						to_be_processed[affixed_word "/" add_and_flags[2] "/" location "4"]=affixed_word "/" add_and_flags[2]
						#debug("---- to be processed (lower level): " affixed_word "/" add_and_flags[2] "/" location "4")
					}
					all_variations[affixed_word]=affixed_word
					delete to_be_processed[word "/" input_flags "/" location]
				}
			}
			else if (location ~ "^(34|234)$" && !complex_prefixes) {
				#debug("-- (34|234) processing suffixed stem: " location)
				for (non_touching_suffix in suffixes_db) {
					split(suffixes_db[non_touching_suffix], affix_particles)
					if (affix_particles[2]!=individual_flags[local_flag]) continue;
					#debug("---- sub suffix- matched suffix " affix_particles[2])
					split(affix_particles[4], add_and_flags, "/")
					cut_chars=(affix_particles[3]=="0" ? 0 : length(affix_particles[3]))
					affixed_word=substr(word, 1, length(word)-cut_chars) (add_and_flags[1]=="0" ? "": add_and_flags[1])
					#debug("--- created sub suffixed word: " affixed_word)
					if (add_and_flags[2]) {
						return_value=1
						to_be_processed[affixed_word "/" add_and_flags[2] "/" location "5"]=affixed_word "/" add_and_flags[2]
					}
					all_variations[affixed_word]=affixed_word
					delete to_be_processed[word "/" input_flags "/" location]
				}
			}
			else {
				#debug("#------------ deleting an entry")
				delete to_be_processed[word "/" input_flags "/" location]
			}
		}
		else if (individual_flags[local_flag] ~ "^"all_prefixes_regex"$" && fx!=1) {
			#debug("- " individual_flags[local_flag] " is PFX")
			if (location ~ "^(3|34|345)$") {
				for (touching_prefix in regexed_prefixes) {
					split(regexed_prefixes[touching_prefix], affix_particles)
					#debug("--- " individual_flags[local_flag] " , " affix_particles[2])
					if (affix_particles[2]!=individual_flags[local_flag]) continue;
					split(affix_particles[4], add_and_flags, "/")
					cut_chars=(affix_particles[3]=="0" ? 0 : length(affix_particles[3]))
					affixed_word=(add_and_flags[1]=="0" ? "": add_and_flags[1]) substr(word, cut_chars+1)
					if (!fx && location !~ 5) {
						# strip out the other suffixes at the same level as the one we re processing
						substring_flags=""
						#debug(all_suffixes_regex)
						split(input_flags, substring_flag_particles, all_prefixes_regex)
						for(i in substring_flag_particles) {
							substring_flags=substring_flags substring_flag_particles[i]
						}
						#debug("prefixes flags: " substring_flags)
						return_value=1
						to_be_processed[affixed_word "/" substring_flags "/" location]=affixed_word "/" substring_flags
						#debug("-- to be processed (same level): " affixed_word "/" substring_flags "/" location)
					}
					if (add_and_flags[2] && complex_prefixes && location !~ 1) {
						return_value=1
						to_be_processed[affixed_word "/" add_and_flags[2] "/2" location]=affixed_word "/" add_and_flags[2]
						#debug("---- to be processed (lower level): " affixed_word "/" add_and_flags[2] "/" location "2")
					}
					all_variations[affixed_word]=affixed_word
					delete to_be_processed[word "/" input_flags "/" location]
				}
			}
			else if (location ~ "^(23|234)$" && complex_prefixes) {
				#debug("-- (23|234) processing prefixed stem: " location)
				for (non_touching_prefix in prefixes_db) {
					split(prefixes_db[non_touching_prefix], affix_particles)
					if (affix_particles[2]!=individual_flags[local_flag]) continue;
					#debug("---- sub prefix- matched prefix " affix_particles[2])
					split(affix_particles[4], add_and_flags, "/")
					cut_chars=(affix_particles[3]=="0" ? 0 : length(affix_particles[3]))
					affixed_word=(add_and_flags[1]=="0" ? "": add_and_flags[1]) substr(word, cut_chars+1)
					#debug("--- created sub prefixed word: " affixed_word)
					if (add_and_flags[2]) {
						return_value=1
						to_be_processed[affixed_word "/" add_and_flags[2] "/1" location]=affixed_word "/" add_and_flags[2]
					}
					all_variations[affixed_word]=affixed_word
					delete to_be_processed[word "/" input_flags "/" location]
				}
			}
			else {
				#debug("#------------ deleting an entry")
				delete to_be_processed[word "/" input_flags "/" location]
			}
		}
	}
	#debug("function thinks to be processed length is " length(to_be_processed))
	#debug("CALL END\n")
	return return_value
}

function get_regex_from_flags(input_flags) {
	delete flag_array
	delete long_flags
	output_regex=""
	temp=""
	
	if (input_flags) {
		split(input_flags, flag_particles, (flag_type=="num" ? "," : "" ))
		if (flag_type=="long") {
			if (length(input_flags)<2) return 0;
			for (i in flag_particles) {
				temp=temp flag_particles[i]
				if (length(temp)==2) {
					#flag_particles[i] && flag_particles[i-1] &&) {
					long_flags[temp]=temp
					temp=""
				}
			}
			for (i in long_flags) {
				flag_array[length(flag_array)+1]=long_flags[i]
			}
		}
		else {
			for (i in flag_particles) {
				flag_array[length(flag_array)+1]=flag_particles[i]
			}
		}
		for (flag in flag_array) {
			if (flag_array[flag]) {
				output_regex=output_regex flag_array[flag] "|"
				#(flag_type!="unicode" ? "|" : "")
			}
		}
		output_regex=substr(output_regex, 1, (length(output_regex) - 1))
		return output_regex
	}
	else {
		return 0
	}
}

# this runs on the .dic file to get stem and flag data
NR==FNR && NR>1 && /\// && NF==1 {
	split($1,dic_line,"/")
	stem=dic_line[1]
	if (dic_line[2]) stem_flags=stem_flags dic_line[2];
}

# this runs on the .dic file to get any stems without flags
NR==FNR && NR>1 && NF==1 && !/\// { stem=$1 }

# this runs on the first line of the .aff file
# to prepare regex to search the file with
NR!=FNR && FNR==1 {
	# generate regex matching all flags used by the stem
	flag_regex="("get_regex_from_flags(stem_flags)")"
	# if no flags have been used then
	# only the dictionary form is correct
	if (!flag_regex) exit 0;
}

# this runs on the .aff file to get affix data
NR!=FNR && /^[SP]FX/ && NF>4 && $4 !~ "[1-9][0-9]*" {
	split($4,a,"/")
	clen=($3=="0") ? 0 : length($3)
	# put every suffix in $affix_db
	if ($1=="SFX" && fx!=2) {
		affix_db[$0]=$0; #could strip out the unused parts of $0?
		suffixes_db[$0]=$0
		all_suffixes_regex=all_suffixes_regex $2 "|"
		flag_to_flag_reference_regex[$0]=(a[2]!="" ? "("get_regex_from_flags(a[2])")" : "")
		if (stem ~ ".*"$5"$" && $2 ~ flag_regex) { regexed_suffixes[$0]=$0; }
		next
	}
	else if ($1=="PFX" && fx!=1) {
		affix_db[$0]=$0; #could strip out the unused parts of $0?
		prefixes_db[$0]=$0
		all_prefixes_regex=all_prefixes_regex $2 "|"
		flag_to_flag_reference_regex[$0]=(a[2]!="" ? "("get_regex_from_flags(a[2])")" : "")
		if (stem ~ "^"$5".*" && $2 ~ flag_regex) { regexed_prefixes[$0]=$0; }
		next
	}
}

# this runs after processing the .aff file
END {
	# if there are no variations to generate
	if (!flag_regex) { print stem; exit 0 }
	
	# generate some variables
	to_be_processed[stem "/" stem_flags "/3"]=stem "/" stem_flags
 	all_variations[stem]=stem
	stem_length=length(stem)
	#debug("all suffixes and prefixes in name arrays:")
	all_suffixes_regex=substr(all_suffixes_regex, 1, length(all_suffixes_regex)-1) ")"
	all_prefixes_regex=substr(all_prefixes_regex, 1, length(all_prefixes_regex)-1) ")"
	#debug("all prefixes: " all_prefixes_regex)
	#debug("all suffixes: " all_suffixes_regex)
	
	process=1
	while (process) {
		process=0
		for (entry in to_be_processed) {
			split(entry, entry_data, "/")
			#if (entry_data[2]>3) continue;
			split(to_be_processed[entry], word_and_flags, "/")
			if (word_and_flags[2]) {
				#debug(to_be_processed[entry])
				if (affix_word(word_and_flags[1], word_and_flags[2], entry_data[3])) process=1;
			}
			else {
				process=1
				all_variations[word_and_flags[1]]=word_and_flags[1]
				delete to_be_processed[entry]
			}
		}
		#debug("to_be_processed length is " length(to_be_processed))
	}
	#debug("exited looping\n")
	
	#print "\n-------------------------------------------------\n" >"/dev/tty"
	#debug("\t\traw variations:")
	for (variation in all_variations) {
		# finally, print all the unique prefix / stem / suffix variations
		print all_variations[variation]
		#print all_variations[variation] >"/dev/tty"
	}
	#print "\n-------------------------------------------------\n" >"/dev/tty"
}
' /tmp/wordforms.dic /tmp/wordforms.aff | hunspell -d /tmp/wordforms -G -l | sort -u
