#!/bin/sh

# check for incorrect number of arguments
case $# in
	0|1|2) echo "Usage: wordforms [-s | -p] dictionary.aff dictionary.dic word
-s: print only suffixed forms
-p: print only prefixed forms";
	exit 1;;
esac
# this switches whether to print only suffixed, prefixed or all forms of stem
fx=0
case $1 in
	-s) fx=1; shift;;
	-p) fx=2; shift;;
esac
# clear any previous temporary dictionary
test -h /tmp/wordforms.aff && rm /tmp/wordforms.aff
# make a symbolic link of the aff file
ln -s "$PWD/$1" /tmp/wordforms.aff

# find all lines exactly matching the search
# stem, plus optional forward slash and flags
entries=""
count=0
for entry in $( grep -E "^$3(/|$)" $2 ) ; do
	[ ! -z $entries ] && entries="$entries|$entry"
	[ -z $entries ] && entries="$entry"
	count=$((count+1))
done
# if no stem was found then exit
[ $count -eq 0 ] && return 1
# number of stems found is the number of entries
# in the temporary dictionary
echo "$count" > /tmp/wordforms.dic
# add entries to temporary dictionary
echo "$entries" | sed 's/|/\n/g' >> /tmp/wordforms.dic

# collect the dictionary settings we need to optimise the word generation
grep -q '^COMPLEXPREFIXES' $1 && complex_prefixes="yes" || complex_prefixes="no"
flag_type="unicode"
case "$( awk '/^FLAG/ && NF>1 { print $2 }' $1 )" in
	num) flag_type="num";;
	long) flag_type="long";;
esac

# generate the different potential words
awk -v fx="$fx" -v complex_prefixes="$complex_prefixes" -v flag_type="$flag_type" '
# this runs before processing the .aff file
BEGIN {
	use_flags=0
	delete stem_flags[0]
}

# this runs on the .dic file to get stem and flag data
NR==FNR && NR>1 && /\// && NF==1 {
	split($1,dic_line,"/")
	stem=dic_line[1]
	if (dic_line[2]) {
		use_flags=1
		split(dic_line[2],flag_particles, (flag_type=="num" ? "," : "" ), blen)
		# correct long flags being split into separate characters
		if (flag_type=="long") {
			for (i in flag_particles) {
				if (i%2==0 && i!=0) {
					long_flags[flag_particles[i-1] flag_particles[i]]=flag_particles[i-1] flag_particles[i]
				}
			}
			for (f in long_flags) {
				stem_flags[length(stem_flags)+1]=long_flags[f]
			}
		}
		else {
			for (f in flag_particles) {
				stem_flags[length(stem_flags)+1]=flag_particles[f]
			}
		}
	}
}

# this runs on the .dic file to get any stems without flags
NR==FNR && NR>1 && NF==1 && !/\// {
	stem=$1
}

# this runs on the first line of the .aff file
# to prepare regex to search the file with
NR!=FNR && FNR==1 {
	# generate regex matching all flags used by the stem
	if (use_flags) {
		flag_regex=flag_regex (flag_type!="unicode" ? "(" : "[")
		for (flag in stem_flags) {
			if (stem_flags[flag]) {
				flag_regex=flag_regex stem_flags[flag] (flag_type!="unicode" ? "|" : "")
			}
		}
		if (flag_type!="unicode") flag_regex=substr(flag_regex, 1, (length(flag_regex) - 1));
		flag_regex=flag_regex (flag_type!="unicode" ? ")" : "]")
	}
	else {
		# if no flags have been used then
		# only the dictionary form is correct
		exit 0
	}
}

# this runs on the .aff file to get suffix data
NR!=FNR && fx!=2 && /^SFX/ && NF>4 && $4 !~ "[1-9][0-9]*" {
	split($4,a,"/")
	clen=($3=="0") ? 0 : length($3)
	# put every suffix in $sfx
	sfx[a[1],clen]=a[1]
	sfxc[a[1],clen]=clen
	sfx_regex[a[1],clen]=$5
	if ($2 ~ "^"flag_regex"$" && stem ~ ".*"$5"$") {
		# add only the suffixes whose regex
		# matches the end of $stem AND matches
		# with a flag on any of the dic entries
		stem_regexed_sfx[a[1],clen]=a[1]
		stem_regexed_sfxc[a[1],clen]=clen
	}
	next
}

# this runs on the .aff file to get prefix data
NR!=FNR && fx!=1 && /^PFX/ && NF>4 && $4 !~ "[1-9][0-9]*" {
	split($4,a,"/")
	clen=($3=="0") ? 0 : length($3)
	# put every prefix in $pfx
	pfx[a[1],clen]=a[1]
	pfxc[a[1],clen]=clen
	if ($2 ~ "^"flag_regex"$" && stem ~ "^"$5".*") {
		# add only the prefixes whose regex
		# matches the start of $stem AND matches
		# with a flag on any of the dic entries
		stem_regexed_pfx[a[1],clen]=a[1]
		stem_regexed_pfxc[a[1],clen]=clen
	}
	next
}

# this runs after processing the .aff file
END {
	# if there are no variations to generate
	if (!use_flags) {
		print stem
		exit 0
	}
	
	wlen=length(stem)
	
	# every potential word goes in this array
	all_variations[stem]=stem
	
	if (fx!=1) {
		# loop through only the array indexes of prefixes that will fit with the stem
		for (j in stem_regexed_pfx) {
			if (wlen<=pfxc[j]) continue;
			pref_stem=(pfx[j]=="0" ? "" : pfx[j]) substr(stem, pfxc[j]+1)
			pswlen=length(pref_stem)
			# add prefixed stem to the array of words to check
			all_variations[pref_stem]=pref_stem
			if (complex_prefixes=="yes") {
				# add the current prefixed stem, with every prefix added to the front
				for (jj in pfx) {
					if (pswlen<=pfxc[jj]) continue;
					pref_pref_stem=(pfx[jj]=="0" ? "" : pfx[jj]) substr(pref_stem, pfxc[jj]+1)
					all_variations[pref_pref_stem]=pref_pref_stem
				}
			}
		}
	}
	if (fx!=2) {
		# loop through only the array indexes of suffixes that will fit with the stem
		for(i in stem_regexed_sfx) {
			if (wlen<=sfxc[i]) continue;
			stem_suff=substr(stem, 1, wlen-sfxc[i]) (sfx[i]=="0" ? "": sfx[i])
			sswlen=length(stem_suff)
			# add suffixed stem to the array of words to check
			all_variations[stem_suff]=stem_suff
			if (complex_prefixes="no") {
				# add the current suffixed stem, with every suffix added to the end
				for (ii in sfx) {
					if (sswlen<=sfxc[ii]) continue;
					stem_suff_suff=substr(stem_suff, 1, sswlen-sfxc[ii]) (sfx[ii]=="0" ? "": sfx[ii])
					all_variations[stem_suff_suff]=stem_suff_suff
				}
			}
		}
	}
	if (fx==0) {
		# generate stems with prefixes and suffixes
		# loop through only the array indexes of affixes that will fit with the stem
		for (j in stem_regexed_pfx) {
			if (wlen<=pfxc[j]) continue;
			for(i in stem_regexed_sfx) {
				if (wlen<=sfxc[i] || wlen <= (sfxc[i] + pfxc[j])) continue;
				pref_stem_suff=(pfx[j]=="0" ? "" : pfx[j]) substr(stem, pfxc[j]+1, wlen-sfxc[i]-pfxc[j]) (sfx[i]=="0" ? "": sfx[i])
				psswlen=length(pref_stem_suff)
				# add the prefixed and suffixed stem
				all_variations[pref_stem_suff]=pref_stem_suff
				if (complex_prefixes=="yes") {
					# add the current prefixed and suffixed stem, with every prefix added to the start
					for (jj in pfx) {
						if (psswlen<=pfxc[jj]) continue;
						pref_pref_stem_suff=(pfx[jj]=="0" ? "" : pfx[jj]) substr(pref_stem_suff, pfxc[jj]+1)
						all_variations[pref_pref_stem_suff]=pref_pref_stem_suff
					}
				}
				else {
					# add the current prefixed and suffixed stem, with every suffix added to the end
					for (ii in sfx) {
						if (psswlen<=sfxc[ii]) continue;
						pref_stem_suff_suff=substr(pref_stem_suff, 1, psswlen-sfxc[ii]) (sfx[ii]=="0" ? "": sfx[ii])
						all_variations[pref_stem_suff_suff]=pref_stem_suff_suff
					}
				}
			}
		}
	}
	for (variation in all_variations) {
		# finally, print all the unique prefix / stem / suffix variations
		print variation
	}
}
' /tmp/wordforms.dic /tmp/wordforms.aff | hunspell -d /tmp/wordforms -G -l
